import tkinter as tk
from tkinter import ttk

from tkinter import filedialog as fd

from math import ceil
from formula import a_sizer
from pathlib import Path
from ctypes import windll

from tkinter.constants import DISABLED, NSEW

class MenuBar:
    # self not necessary?
    def __init__(self, root):
        root.option_add('*tearOff', False)
        menubar = tk.Menu(root)
        root['menu'] = menubar
        menu_file = tk.Menu(root)
        menubar.add_cascade(label='File', menu=menu_file)
        menu_file.add_command(label='Open...', command = fd.askopenfilename)
        menu_file.add_command(label='Save', command = lambda: print('save PLACEHOLDER'))
        menu_file.add_command(label='Save As...', command = fd.asksaveasfilename)
        menu_edit = tk.Menu(root)
        menubar.add_cascade(label='Edit', menu=menu_edit)
        menu_edit.add_command(label='Preset 1')
        menu_edit.add_command(label='A5')
        menu_view = tk.Menu(root)
        menubar.add_cascade(label='View', menu=menu_view)
        menu_view.add_command(label='Portrait/Landscape')
        menu_help = tk.Menu(root)
        menubar.add_cascade(label='Help', menu=menu_help)
        menu_help.add_command(label='Github')
        menu_help.add_command(label='email@test')
        menu_help.entryconfigure('email@test', state=DISABLED) # copy symbol

class PdfCanvas:
    """Widget collection for PDF display and guideline interaction."""
    
    bd = 10
    """Image subframe border between canvas and scrollbars."""
    lt = 5
    """Line thickness also decides internal canvas padding."""

    def __init__(self, root, master):
        self.root = root
        self.master = master
        subframe_scrollbut=ttk.Frame(master)#tk., bd=1, bg=debugc)
        subframe_scrollbut.grid_propagate(False)
        subframe_scrollbut.grid(column=1, row=0, sticky=NSEW)
        subframe_scrollbut.columnconfigure(0, weight=1)
        subframe_scrollbut.rowconfigure(0, weight=1)

        subframe_image=tk.Frame(master, relief='sunken', bd=self.bd)
        subframe_image.grid(column=0, row=1)
        subframe_image.columnconfigure(0, weight=1)
        subframe_image.rowconfigure(0, weight=1)

        im_scrollh=ttk.Scrollbar(master, orient='horizontal')
        im_scrollh.grid(column=0, row=0, sticky='we')

        im_scrollv=ttk.Scrollbar(master, orient='vertical')
        im_scrollv.grid(column=1, row=1, sticky='ns')

        self.im_scrollbut=ttk.Button(subframe_scrollbut)
        self.im_scrollbut.grid()

        # def init_canvas(lt):            
        self.canvas=tk.Canvas(subframe_image, bg='grey',
            highlightthickness = 0, highlightcolor = 'white', # todo I think was just for testing
            xscrollcommand=im_scrollh.set, yscrollcommand=im_scrollv.set)
               # scrollregion=(0,0,width,height))
        # im_scrollh['command']=canvas.xview
        # im_scrollv['command']=canvas.yview
        # print(self.im_canvas['highlightthickness'])
        self.canvas.grid(sticky=NSEW)

        # anchor nw for guillotine metaphor (todo opt)
        self.raster = self.canvas.create_image(self.lt, self.lt, anchor='nw')

        # return canvas, pdf_item

        self.images = {}

    def unconv(self, i, lm):
        noborder = i - lm['conv'] # subtracts border
        og = noborder * self.pdf['sample']
        return og

    def get_coords(self, ln) -> tuple:
        """Return coordinate values unaltered, retrieving actual value
        of any Int/DoubleVar, other coordinate values are constant.
        """
        coords = ln['coords']
        return tuple(x.get() if type(x) is tk.IntVar else x for x in coords)
        # match coords[0]:
        #     case 'h': return tuple(x.get() if type(x) is DoubleVar else x for x in coords)
        #     case 'v': return tuple(x.get() if type(x) is DoubleVar else x for x in coords)

    def make_lines(self, **kwargs):
        # for ln in list(line_matrix):
        for key, ln in self.line_matrix.items():
            # lm = line_matrix[ln]
            ln['line'] = self.canvas.create_line(self.get_coords(ln), **kwargs)
            self.canvas.coords(ln['line'], self.get_coords(ln))
            match key[0]:
                case 'h':
                    ln['direction'] = 'y'
                case 'v':
                    ln['direction'] = 'x'
                    
    def init_lines(self, lt):
        debug_lt = lt
        lineo = lt//2 #-(lt%2)
        pdf = self.pdf['scaled']
        xe = pdf.width()  + lt * 2
        ye = pdf.height() + lt * 2

        # NSEW unsorted list() order matters for self.move_line
        self.line_matrix = {}
        for ln in ['h0', 'h1', 'v0', 'v1']:
            lm = self.line_matrix[ln] = {}
            p = tk.IntVar(self.root) # type check in get_coords
            lm['pos'] = p
            dim = 0
            match ln[0]:
                case 'h':
                    dim = pdf.height() # ? make var for spinbox limit access
                    lm['coords'] = [0, p, xe, p]
                    lm['limit'] = ye - lineo - 1
                case 'v':
                    dim = pdf.width()
                    lm['coords'] = [p, 0, p, ye]
                    lm['limit'] = xe - lineo - 1 # todo can use ogpos instead
            match ln[1]:
                case '0':
                    val = lm['conv'] = lineo
                    p.set(val)
                case '1':
                    # line width pad + entire left border (line thickness)
                    # simpler as 3x lineo + 1 (line centre)?
                    lm['conv'] = lineo + lt
                    val = dim + lm['conv']
                    p.set(val)
            lm['ogpos'] = p.get()
            lm['unconv'] = tk.IntVar(self.root, self.unconv(lm['pos'].get(), lm))
        self.make_lines(width=debug_lt, fill='red')
        return self.line_matrix

    def size(self, width, height):
        self.canvas['width']=str(width + self.lt)+'m'
        self.canvas['height']=str(height + self.lt)+'m'

    def a_size(self, a_size):
        """A-series paper size eg. A4
        # TODO other standard print sizes eg. US
        # not used once imaged resized
        """
        width, height = a_sizer(a_size)
        self.size(width, height)

    # scroll guillotine with bar
    def canvas_fit(self, img):
        self.canvas['width']  = img.width() + self.lt*2  # + (self.lt - self.bd) * 2
        self.canvas['height'] = img.height() + self.lt*2 # + (self.lt - self.bd) * 2

    def image_scale(self, root, image, factor):
        img = image['og']
        sample = image['sample']
        if factor == 0:
            # no pre-subsample filtering / downscale => aliasing
            scaled = img.subsample(sample)
        else:
            scaled = img.zoom(factor)
        root.image = scaled # maintain reference w/o PIL
        self.canvas.itemconfigure(self.raster, image=scaled)
        image['scaled'] = scaled
        canvas_o = self.lt * 2
        self.canvas['scrollregion']=(0, 0, scaled.width() + canvas_o,
                                     scaled.height() + canvas_o)

    def set_image(self, filename):
        i_file = Path(filename)
        name = i_file.stem # todo ^ combine
        # todo hc mode opt to use bitmap (like pdf.js)
        og = tk.PhotoImage(master=self.root, file=filename) # master=self.im_canvas

        # calc nearest integer scaling to fit canvas
        subx = (float(self.canvas['width'])  + self.lt) / og.width()
        suby = (float(self.canvas['height']) + self.lt) / og.height()
        sample = ceil(1/min(subx, suby))

        self.pdf = {'og': og, 'path': filename, 'sample': sample}
        self.images[name] = self.pdf
        self.image_scale(self.root, self.pdf, 0)

        self.canvas_fit(self.pdf['scaled'])

        return name

if __name__ == "__main__":
    windll.shcore.SetProcessDpiAwareness(2)
    root = tk.Tk()
    PdfCanvas(root, root)
    root.mainloop()
